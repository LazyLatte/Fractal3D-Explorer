layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba16f) uniform image2D dstImage;

layout (std140, binding = 0) uniform Camera { 
    vec3 pos; 
    vec3 front;
};

#define PI 3.14159265
#define HALF_PI 1.570796

#include <DE.glsl>
#define RAY_STEP 500
#define FOV 1.5
#define FAR_PLANE 20.0

uniform vec3 color_seed;
const float gloss = 8.0;
const vec3 lightColor = vec3(1.0);
const float lightIntensity = 1.0f;
const vec3 lightDir = vec3(-0.8, -0.6, 0.0);

const float ray_multiplier = 0.8;


const int shadow_step = 1500;
const float step_limiter = 0.2;
float softshadow(vec3 ro, vec3 rd, float k) {
    float res = 1.0;
    float t = 0.0; 
    for (int i = 0; i < shadow_step; i++) {
        vec2 map = DE(ro + rd * t);
        float h = map.x;
        res = min(res, k * h / t); 
        
        t += clamp(h, 0.001f, step_limiter); 
        if(res < 0.02 || t > FAR_PLANE) break;
    }
    return clamp(res, 0.02, 1.0);
}

vec3 palette(float t, vec3 d){
    vec3 a = vec3(0.75);
    vec3 b = vec3(0.25);
    vec3 c = vec3(1.0);
    return a + b * cos(2.0 * PI * (c * t + d));
}

float TrowbridgeReitz_NDF(float NoH, float a){
    float a2 = a * a;
    float denom = NoH * NoH * (a2 - 1.0) + 1.0;

    return a2 / (PI * denom * denom);
}

float GGX_GSF(float NoV, float NoL, float a){
    float a2 = a * a;
    float SmithL = (2.0 * NoL) / (NoL + sqrt(a2 + (1.0 - a2) * NoL * NoL));
    float SmithV = (2.0 * NoV) / (NoV + sqrt(a2 + (1.0 - a2) * NoV * NoV));
    return SmithL * SmithV;
}

vec3 FresnelSchlick(float cosTheta, vec3 F0){
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float hash(vec3 p) { return fract(sin(dot(p, vec3(12.3, 45.6, 78.9))) * 43758.5453); }

float noise(vec3 p) {
    vec3 i = floor(p), f = fract(p);
    f = f*f*(3.0-2.0*f);
    float n = mix(mix(mix(hash(i+vec3(0,0,0)), hash(i+vec3(1,0,0)), f.x),
                      mix(hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)), f.x), f.y),
                  mix(mix(hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)), f.x),
                      mix(hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)), f.x), f.y), f.z);
    return n;
}

float fbm(vec3 p) {
    float v = 0.0, a = 0.5;
    for(int i = 0; i < 5; i++) {
        v += a * noise(p);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}


void main() {
    ivec2 dstTexel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iResolution = imageSize(dstImage);

    vec2 uv = (dstTexel * 2.0 - iResolution) / iResolution.y;
    vec3 right = cross(front, vec3(0.0, 1.0, 0.0));
    vec3 up = cross(right, front);
    vec3 dir = normalize(uv.x * right + uv.y * up + FOV * front);

    float dist = 0.0;
    float orbit = 0.0;
    float eps;
    for(int i=0; i<RAY_STEP; i++){
        vec2 map = DE(pos + dist * dir);
        float est = map.x;
        orbit = map.y;
        //eps = max(dist * 0.002f, 0.001f);
        eps = dist * 0.002f;
        if(abs(est) < eps || dist > FAR_PLANE) break;
        dist += est * ray_multiplier;
    }
    
    
    vec3 color = vec3(0.0);

    if(dist < FAR_PLANE){
        vec3 P = pos + dist * dir;
        
        vec3 N = normalize(vec3(
            DE(P + vec3(eps, 0.0, 0.0))[0] - DE(P - vec3(eps, 0.0, 0.0))[0],
            DE(P + vec3(0.0, eps, 0.0))[0] - DE(P - vec3(0.0, eps, 0.0))[0],
            DE(P + vec3(0.0, 0.0, eps))[0] - DE(P - vec3(0.0, 0.0, eps))[0]
        ));
        vec3 V = -dir;
        vec3 L = normalize(-lightDir);
        vec3 H = normalize(L + V);

        float NoH = max(dot(N, H), 0.0);
        float NoV = max(dot(N, V), 0.0);
        float NoL = max(dot(N, L), 0.0);
        float VoH = max(dot(V, H), 0.0);

        //PBR
        float n = fbm(P * 2.5);

        vec3 rockColor = mix(vec3(0.25, 0.2, 0.15), vec3(0.7, 0.65, 0.6), n);
        float veinMask = smoothstep(0.6, 0.8, fbm(P * 10.0));
        vec3 veinColor = mix(rockColor, vec3(0.9, 0.85, 0.8), veinMask);
        float roughness = mix(0.8, 0.3, veinMask);
        float metallic = step(0.85, n);
        vec3 albedo = veinColor;

        //vec3 albedo = palette(1.0 - orbit, color_seed);
        vec3 radiance = 5.0 * vec3(255.0, 255.0, 255.0) / 255.0;
        float D = TrowbridgeReitz_NDF(NoH, roughness);
        float G = GGX_GSF(NoV, NoL, roughness);

        vec3 F0 = mix(vec3(0.04), albedo, metallic);
        vec3 F = FresnelSchlick(VoH, F0);

        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - metallic;

        vec3 specular = (D * G * F) / max(4.0 * NoV * NoL, 0.0001);

        vec3 BRDF = kD * albedo / PI + specular;

        vec3 Lo = BRDF * radiance * NoL;
        vec3 ambient = albedo * smoothstep(0.0, 1.0, orbit) * 1.6;

        float sdw =  softshadow(P + eps * N, L, 16.0);
        color = sdw * Lo + ambient;
        //color = ambient * 1.5;
    }
    // color.x = color.x > 1.0 ? 0.0 : 1.0;
    // color.y = color.y > 1.0 ? 0.0 : 1.0;
    // color.z = color.z > 1.0 ? 0.0 : 1.0;
    //float test = smoothstep(0.0, 1.0, orbit) * 1.5;
    //color = vec3(test);
    imageStore(dstImage, dstTexel, vec4(color, 1.0));
}